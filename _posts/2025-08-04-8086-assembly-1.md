---
title: Surviving the 8086 Assembly Course
date: 2025-08-05 00:00:00 +/-0600
categories: [Low Level, 8086 Assembly]
tags: [lab, exam]     # TAG names should always be lowercase
description : "The blog series which contains all the core components to know so that you can pass your 8086 assembly lab course"
math: true
---

# Pretalk
If you're studying in Bangladesh or India, there's a good chance that your assembly language practical course uses **8086 Assembly** with the **EMU8086** software. This approach is quite common in academic settings. However, it's also true that assembly language isn't widely used in most modern development workflows, so many instructors may have limited hands-on experience with it beyond their own education. As a result, some of the teaching may focus more on theory than practical, real-world applications.

But you have to pass this course with and you cannot bullshit your way through considering the examiner's theoratical knowledge will kick off the  bullshit sensor in their brain when you try to do so. So we will focus on only the necessary things we need to know to make sure we don't fail and we don't trip their bullshit sensor as well.

## Knowledge needed
If you are using **EMU8086** in the exam you can get pass by using the built in snippets but most teachers will just cut some portions of the program and make you rewrite that on the spot, in that case you need to know some theory and coding tricks before you even try to attempt something

1. Registers and memory of the 8086 microprocessor
2. Sections of assembly code
2. Which instructions with which memory can work and which combinations of source and destinations are legal
3. The AH value that does special functions that you may need to use
4. The process of coding it in any low level language like C
5. Commenting the code frequently to make the code more readable and use the C program as your coding reference

## 8086 Registers
![8086 memory shown in emu8086 software](/assets/images/emu8086.png)

8086 microprocessor is a 16bit microprocessor and there are three kinds of registers in 8086 microprocessors. they are
1. General Purpose Registers
<table width='100%'>
  <tr>
    <th>16-bit</th>
    <th>High byte (8-bit)</th>
    <th>Low byte (8-bit)</th>
    <th>Common Use</th>
  </tr>
  <tr>
    <td>AX</td>
    <td>AH</td>
    <td>AL</td>
    <td>Accumulator (for arithmetic)</td>
  </tr>
  <tr>
    <td>BX</td>
    <td>BL</td>
    <td>BH</td>
    <td>Base (used in addressing)</td>
  </tr>
  <tr>
    <td>CX</td>
    <td>CH</td>
    <td>CL</td>
    <td>Counter (used in loops, shifts)</td>
  </tr>
  <tr>
    <td>DX</td>
    <td>DH</td>
    <td>DL</td>
    <td>Data (used in I/O, multiplication)</td>
  </tr>
</table>
2. Index Pointer Registers
<table width='100%'>
  <tr>
    <th>Register</th>
    <th>Purpose</th>
  </tr>
  <tr>
    <td>SP</td>
    <td>Stack Pointer (points to top of the stack)</td>
  </tr>
  <tr>
    <td>BP</td>
    <td>Base Pointer (used to access parameters in stack frames)</td>
  </tr>
  <tr>
    <td>SI</td>
    <td>Source Index (used in string/memory operations)</td>
  </tr>
  <tr>
    <td>DI</td>
    <td>Destination Index (used in string/memory operations)</td>
  </tr>
</table>

3. Segment Registers

<table width='100%'>
  <thead>
    <tr>
      <th>Register</th>
      <th>Purpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CS</td>
      <td>Code Segment (where instructions are fetched from)</td>
    </tr>
    <tr>
      <td>DS</td>
      <td>Data Segment (default for variables)</td>
    </tr>
    <tr>
      <td>SS</td>
      <td>Stack Segment (used with the stack)</td>
    </tr>
    <tr>
      <td>ES</td>
      <td>Extra Segment (used for string operations)</td>
    </tr>
  </tbody>
</table>

4. Flag Registers

<table width='100%'>
  <thead>
    <tr>
      <th>Flag</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CF</td>
      <td>Carry Flag</td>
    </tr>
    <tr>
      <td>ZF</td>
      <td>Zero Flag</td>
    </tr>
    <tr>
      <td>SF</td>
      <td>Sign Flag</td>
    </tr>
    <tr>
      <td>OF</td>
      <td>Overflow Flag</td>
    </tr>
    <tr>
      <td>PF</td>
      <td>Parity Flag</td>
    </tr>
    <tr>
      <td>AF</td>
      <td>Auxiliary Carry (used in BCD)</td>
    </tr>
    <tr>
      <td>DF</td>
      <td>Direction Flag (used in string ops)</td>
    </tr>
    <tr>
      <td>IF</td>
      <td>Interrupt Enable Flag</td>
    </tr>
  </tbody>
</table>

## Code Sections
 In **8086 Assembly**, the program is typically divided into several **segments**, each with a specific purpose.

Here's a breakdown of the most commonly used segments:

### `.model`

The `.model` directive specifies the **memory model** of the program — it tells the assembler how code and data are organized.

#### Common Memory Models:

| Memory Model    | Description                                        |
| --------------- | -------------------------------------------------- |
| `.model tiny`   | Code + data fit in 1 segment (COM programs)        |
| `.model small`  | Code and data each have **one** segment            |
| `.model medium` | Code can span **multiple** segments, data in one   |
| `.model large`  | Code and data both can be in **multiple** segments |

**For beginners**, `.model small` is the most commonly used.

```asm
.model small
```
### `.data`

The `.data` segment is where you declare **initialized variables** (data that has a known starting value).

#### Examples:

```asm
.data
msg     db  'Hello, World$', 0
number  dw  1234h
```

| Keyword | Meaning              |
| ------- | -------------------- |
| `DB`    | Define Byte (8-bit)  |
| `DW`    | Define Word (16-bit) |
| `DD`    | Define Double Word   |

### `.stack`

The `.stack` segment reserves memory for the **stack**, which is used for function calls, pushing/popping values, etc.

You define how much memory (in bytes) you want to allocate for it:

```asm
.stack 100h   ; reserve 256 bytes for the stack
```
Stack operations use `SP` (Stack Pointer) and `SS` (Stack Segment) registers.

### `.code`

This is where you write your **actual instructions** (the program logic). It corresponds to the **Code Segment (CS)** in memory.

#### Typical Structure:

```asm
.code
main proc
    mov ax, @data
    mov ds, ax

    ; Program codes 

    mov ah, 4ch
    int 21h    ; exit to DOS
main endp
```


## Memory Permutations
In 8086 (and most x86 architectures), you cannot use two memory operands in a single instruction. For example:

Valid example:
```asm
MOV AX, [BX]     ; move from memory at address in BX to AX
MOV [SI], AX     ; move from AX into memory at address in SI
```
Invalid (two memory operands) example:
```asm
MOV [BX], [SI]   ; illegal: both source and destination are memory
```
### Why this happens:
In x86 architecture, the CPU's instruction set encoding doesn't support directly transferring data from one memory location to another in a single instruction. It requires the CPU to work with a register as an intermediary.

So you must break it into two steps:

```asm
MOV AX, [SI]     ; load from source memory
MOV [BX], AX     ; store into destination memory
```
### General Rule of Thumb:
Only one memory operand is allowed in most x86 instructions (MOV, ADD, SUB, etc.) — the other operand must be a register or an immediate value.

Allowed Combinations in MOV:
1. Register ↔ Register
2. Register ↔ Memory
3. Register ↔ Immediate

not allwed in MOV
1. Memory ←→ Memory

One trick is to use register to register for all instructions. as that is allowd in all of the instructions

## AH functions
DOS Interrupt 21h Functions are the one used in AH and that value does some particular task. The task corresponding to the value is
<table width='100%'>
  <thead>
    <tr>
      <th><code>AH</code> Value</th>
      <th>Function Name</th>
      <th>Purpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>01h</code></td>
      <td>Input character (with echo)</td>
      <td>Waits for keypress and echoes it on screen</td>
    </tr>
    <tr>
      <td><code>02h</code></td>
      <td>Display character</td>
      <td>Prints the character in <code>DL</code></td>
    </tr>
    <tr>
      <td><code>06h</code></td>
      <td>Direct console I/O</td>
      <td>Input/output without echo</td>
    </tr>
    <tr>
      <td><code>07h</code></td>
      <td>Input character (no echo)</td>
      <td>Like <code>01h</code> but without echoing</td>
    </tr>
    <tr>
      <td><code>08h</code></td>
      <td>Input character (no echo, no wait)</td>
      <td>Reads a key only if one is pressed</td>
    </tr>
    <tr>
      <td><code>09h</code></td>
      <td>Display string</td>
      <td>Displays a <code>$</code>-terminated string from <code>DX</code></td>
    </tr>
    <tr>
      <td><code>0Ah</code></td>
      <td>Buffered string input</td>
      <td>Reads string input into a buffer (first byte = max length)</td>
    </tr>
    <tr>
      <td><code>0Eh</code></td>
      <td>Select default drive</td>
      <td><code>DL = drive number (0=A, 1=B, etc.)</code></td>
    </tr>
    <tr>
      <td><code>25h</code></td>
      <td>Set interrupt vector</td>
      <td>Change ISR for a given interrupt</td>
    </tr>
    <tr>
      <td><code>2Ah</code></td>
      <td>Get system date</td>
      <td>Returns date in CX, DX, AL</td>
    </tr>
    <tr>
      <td><code>2Ch</code></td>
      <td>Get system time</td>
      <td>Returns time in CX, DX</td>
    </tr>
    <tr>
      <td><code>31h</code></td>
      <td>Terminate and stay resident</td>
      <td>Keeps part of the program in memory (TSR)</td>
    </tr>
    <tr>
      <td><code>4Ch</code></td>
      <td>Terminate program</td>
      <td>End program with optional return code in <code>AL</code></td>
    </tr>
  </tbody>
</table>

## Conclusion
This are all the theories that are absolutely necessary to make sure you can at least get past the minimum requirement to at least read the template codes in the software and get past the coding task.
